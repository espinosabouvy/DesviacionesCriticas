{
    "collab_server" : "",
    "contents" : "#ANALISIS DE PRODUCCION\n\nlibrary(shiny)\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(plotly)\n\n\nshinyServer(function(input, output, session) {\n     options(shiny.maxRequestSize=15*1024^2)\n     \n     #tabla vacia para cargar pares por linea\n     tb.porproduc <- data.frame(\"Linea\" = numeric(0), \"Pares\" = numeric(0))\n     \n     #lectura inicial de datos y transformacion al formato requerido de estilo-puesto1-puesto2\n     lectura.inicial <- reactive({\n          require(dplyr)\n          require(tidyr)\n          \n          inFile <- NULL\n          inFile <- input$browse          \n          #inFile$datapath <- \"tiempos.csv\"\n          \n          if (is.null(inFile)){\n               #sin archivo seleccionado\n               return(NULL)\n          }\n          \n          #leer por tipo de archivo\n          tiempos.raw <- read.csv(inFile$datapath, \n                            header = TRUE, na.strings = c(\"NA\",\"\"))\n          \n          #limpiar el formato, actual (LINEA, VCESTIL, PARES, FAMPESP, FAMMONT, DEPTO, FUNCION, TIEMPO,\n          #PERSONAS, META)\n\n          deptos.usar <- c(\"CORTE\",\"CORTE Y PREPARA\", \"ENSAMBLES\", \"FAMILIA\", \"FORRADOS\", \n                           \"PLANTA\", \"RAYADO Y RESACA\",\n                           \"SUELA\")\n          \n          tiempos.raw <- tiempos.raw%>%\n               select(DEPTO, VCESTIL, FAMPESP, FUNCION, TIEMPO)%>%\n               filter(DEPTO %in% deptos.usar)%>%\n               filter(TIEMPO > 0)\n          \n          #agrupar pespuntadores y preliminares\n          tiempos.raw$FUNCION <- ifelse(grepl(\"PESPUNTADOR\", \n                                              tiempos.raw$FUNCION),\"PESPUNTADOR\",\n                                        paste(tiempos.raw$FUNCION))\n          tiempos.raw$FUNCION <- ifelse(grepl(\"CA-PES\", \n                                              tiempos.raw$FUNCION),\"PESPUNTADOR\",\n                                        paste(tiempos.raw$FUNCION))\n          #corregir del sistema, mientras, debe desaparecer\n          tiempos.raw$FUNCION <- ifelse(grepl(\"PRECONFORM\", \n                                              tiempos.raw$FUNCION),\"PRELIMINAR\",\n                                        paste(tiempos.raw$FUNCION))\n          tiempos.raw$FUNCION <- ifelse(grepl(\"PRELIM\", \n                                              tiempos.raw$FUNCION),\"PRELIMINAR\",\n                                        paste(tiempos.raw$FUNCION))\n          tiempos.raw$FUNCION <- ifelse(grepl(\"CA-PRE\", \n                                              tiempos.raw$FUNCION),\"PRELIMINAR\",\n                                        paste(tiempos.raw$FUNCION))\n          tiempos.raw$FUNCION <- ifelse(grepl(\"C-PREA\", \n                                              tiempos.raw$FUNCION),\"PRELIMINAR\",\n                                        paste(tiempos.raw$FUNCION))\n          tiempos.raw$FUNCION <- ifelse(grepl(\"CA-COR\", \n                                              tiempos.raw$FUNCION),\"CORTADOR PIEL\",\n                                        paste(tiempos.raw$FUNCION))\n          tiempos.raw$FUNCION <- ifelse(grepl(\"CORTADOR FLASH\", \n                                              tiempos.raw$FUNCION),\"CORTADOR PIEL\",\n                                        paste(tiempos.raw$FUNCION))\n          tiempos.raw$FUNCION <- ifelse(grepl(\"PRECONF\", \n                                              tiempos.raw$FUNCION),\"PRECONFORMADOR\",\n                                        paste(tiempos.raw$FUNCION))\n          tiempos.raw$FUNCION <- ifelse(grepl(\"CA-PREC\", \n                                              tiempos.raw$FUNCION),\"PRECONFORMADOR\",\n                                        paste(tiempos.raw$FUNCION))\n          tiempos.raw$FUNCION <- ifelse(grepl(\"CA-DOB\", \n                                              tiempos.raw$FUNCION),\"DOBLILLADOR\",\n                                        paste(tiempos.raw$FUNCION))\n          tiempos.raw$FUNCION <- ifelse(grepl(\"CA-REB\", \n                                              tiempos.raw$FUNCION),\"REBAJADOR\",\n                                        paste(tiempos.raw$FUNCION))\n          tiempos.raw$FUNCION <- ifelse(grepl(\"REBAJADOR PIEL\", \n                                              tiempos.raw$FUNCION),\"REBAJADOR\",\n                                        paste(tiempos.raw$FUNCION))\n          #forrar de plantas a ribeteador\n          if (nrow(tiempos.raw[tiempos.raw$FUNCION == \"FORRAR\" & tiempos.raw$DEPTO == \"PLANTA\",])>0){\n               tiempos.raw[tiempos.raw$FUNCION == \"FORRAR\" & tiempos.raw$DEPTO == \"PLANTA\",]$FUNCION <- \"RIBETEADOR\"\n          }\n          \n          #quitar comodines\n          tiempos.raw <- tiempos.raw[!grepl(\"COMODIN+\",  tiempos.raw$FUNCION),]\n          \n          #nombres correctos\n          names(tiempos.raw) <- make.names(names(tiempos.raw))\n          tiempos <- tiempos.raw%>%\n               select(DEPTO, \"ESTILO\" = VCESTIL, \"LINEA\" = FAMPESP, FUNCION, TIEMPO)\n          \n          \n          #hacer correcciones al archivo y llenar combo para seleccionar depto\n          if (is.null(tiempos)){\n               #sin archivo seleccionado\n               return(NULL)\n          }\n          \n\n          #llenar combo de departamentos con el archivo preparado\n\n          output$depto.select <- renderUI({\n               deptos <- unique(tiempos$DEPTO)\n               selectInput(\"depto.selected\", \"Selecciona el departamento que quieres analizar\", as.list(deptos))\n          })\n          \n\n          #llenar combo de lineas de produccion con el archivo preparado\n          output$fams.select <- renderUI({\n               fams <- unique(tiempos$LINEA)%>%sort()\n               selectInput(\"fams.selected\", \"Selecciona las lineas que quieres analizar\", as.list(fams), multiple = TRUE)\n          })\n          \n          \n          return(tiempos)\n     })\n          \n \n          \n     #Datos leidos - tabla de estilos y tiempos\n     output$tabla_completa <- DT::renderDataTable({\n          tabla.raw <- reporte.final()\n          if(is.null(tabla.raw)) return(NULL)\n          \n          DT::datatable(tabla.raw, options = list(pageLength = 25))\n     })\n     \n     \n     #Menu - filtra deptos y lineas, completa con cero las funciones que no aparecen en los deptos\n     #esto es logico, pues no se cargan los puestos que no se utilizan, pero si causan desviacion\n     #pues realmente se tiene gente y no se utiliza.  NO CORRIGE AL SELEECIONAR MOSTRAR COMO PERSONAS\n     \n     reporte.final.sin.personas <- reactive({\n          datos <- lectura.inicial()\n          if (is.null(datos)){\n               #sin archivo seleccionado\n               return(NULL)\n          }\n          \n          #leer combo y definir lineas a usar, sirve para quitar estilos sin linea asignada\n          #y para quitar canteras o maquilas, dan problemas al agrupar en un solo depto pues\n          # en realidad es no se procesa junto\n          if (is.null(input$fams.selected)) return(NULL)\n          \n          datos <- datos%>%\n               filter(LINEA %in% input$fams.selected)\n          \n          #completar con cero las funciones que existen en cada depto y el estilo no las tiene\n          #primero se debe agregar todos los estilos a todas los deptos\n          estilos.fam <- unique(datos[datos$DEPTO == \"FAMILIA\",2:3])\n          #estilos.fam <<- unique(datos[datos$DEPTO == \"FAMILIA\",2:3])\n          \n          #verificar que esa linea tenga ese departamento\n          if (nrow(datos[datos$DEPTO== input$depto.selected,]) == 0) return(NULL)\n          \n          #hacer esto cuando se seleccione el depto\n          temp <- datos%>%\n               filter(DEPTO == input$depto.selected)%>%\n               select(ESTILO, FUNCION, TIEMPO)%>%\n               group_by(ESTILO, FUNCION)%>%\n               summarise(\"TIEMPO\" = sum(TIEMPO))%>%\n               spread(FUNCION,TIEMPO, drop = FALSE, fill = 0)\n          datos <- merge(estilos.fam, temp, by = \"ESTILO\")\n          \n          \n          #agrupar en una sola linea\n          #cambia los datos de la columna linea todo a 1\n          if(input$agrupado){\n               datos[,2] <- 1\n          }\n          \n          #convertir NAS en cero\n          datos[is.na(datos)]<-0\n\n          #estilo y linea como factor\n          datos[,1] <- as.factor(datos[,1])\n          datos[,2] <- as.factor(datos[,2])\n          #nas a cero\n          datos[is.na(datos)]<-0\n          \n          #limitar cantidad de modelos\n          #datos<- datos[1:20,]\n          \n          \n          return(datos)\n          \n     })  \n\n     #Menu - filtra deptos y lineas, completa con cero las funciones que no aparecen en los deptos\n     #esto es logico, pues no se cargan los puestos que no se utilizan, pero si causan desviacion\n     #pues realmente se tiene gente y no se utiliza.\n     #CALCULA PERSONAS EN LUGAR DE TIEMPOS, BASADO EN 100 PARES POR HORA\n     \n     reporte.final <- reactive({\n          datos <- lectura.inicial()\n          if (is.null(datos)){\n               #sin archivo seleccionado\n               return(NULL)\n          }\n          \n          #leer combo y definir lineas a usar, sirve para quitar estilos sin linea asignada\n          #y para quitar canteras o maquilas, dan problemas al agrupar en un solo depto pues\n          # en realidad es no se procesa junto\n          if (is.null(input$fams.selected)) return(NULL)\n          \n          \n          datos <- datos%>%\n               filter(LINEA %in% input$fams.selected)\n          \n          #convertir los tiempos en personas utilizando sliders (para 1000 pares por dia)\n          if (input$personas) {\n               efic <- input$eficiencia/100\n               hrs <- input$horas.trabajo\n               datos <-  datos%>%\n                    mutate(\"PERSONAS\" = ceiling(TIEMPO*1000/(efic*hrs*3600)))%>%\n                    select(DEPTO, ESTILO, LINEA, FUNCION, \"TIEMPO\" = PERSONAS)\n          }\n          \n          #completar con cero las funciones que existen en cada depto y el estilo no las tiene\n          #primero se debe agregar todos los estilos a todas los deptos\n          estilos.fam <- unique(datos[datos$DEPTO == \"FAMILIA\",2:3])\n\n          #verificar que esa linea tenga ese departamento\n          if (nrow(datos[datos$DEPTO== input$depto.selected,]) == 0) return(NULL)\n          \n          #hacer esto cuando se seleccione el depto\n          temp <- datos%>%\n               filter(DEPTO == input$depto.selected)%>%\n               select(ESTILO, FUNCION, TIEMPO)%>%\n               group_by(ESTILO, FUNCION)%>%\n               summarise(\"TIEMPO\" = sum(TIEMPO))%>%\n               spread(FUNCION,TIEMPO, drop = FALSE, fill = 0)\n          datos <- merge(estilos.fam, temp, by = \"ESTILO\")\n          \n          \n          #agrupar en una sola linea\n          #cambia los datos de la columna linea todo a 1\n          if(input$agrupado){\n               datos[,2] <- 1\n          }\n          \n          #convertir NAS en cero\n          datos[is.na(datos)]<-0\n          \n          #estilo y linea como factor\n          datos[,1] <- as.factor(datos[,1])\n          datos[,2] <- as.factor(datos[,2])\n          #nas a cero\n          datos[is.na(datos)]<-0\n          \n          #limitar cantidad de modelos\n          #datos<- datos[1:20,]\n          \n          \n          return(datos)\n          \n     })  \n     \n     # General - Drop-down de linea a definir pares por producir\n     output$lineas.selected <- renderUI({\n          num.fam <- reporte.final()\n          if(is.null(num.fam)) return(NULL)\n          \n          l.linea <- unique(num.fam$LINEA)%>%sort()\n          selectInput(\"linea.seleccionada\", \"Linea de produccion\", as.list(l.linea))\n     })\n     \n     #General - crea la tabla de pares por producir por linea\n     actualiza <- eventReactive(input$agregar, {\n          #agregar a la tabla los pares\n          l.linea <- input$linea.seleccionada\n          pares <- as.numeric(input$pares)\n          \n          temp <- data.frame(\"LINEA\" = l.linea, \"PARES\" = pares)\n          \n          #quita la linea que existe (actualizar)\n          tb.porproduc <- tb.porproduc%>%filter(LINEA != l.linea)\n          tb.porproduc <<- rbind(tb.porproduc, temp)%>%\n               arrange(LINEA)\n     })\n     \n     #General - imprime tabla de pares por producir\n     output$por.producir <- DT::renderDataTable({\n\n          tabla <- actualiza()               \n          DT::datatable(tabla, options = list(dom = 't'))\n     })\n     \n     \n     # General - Drop-down de linea a filtrar\n     output$seleccion_linea <- renderUI({\n          num.fam <- reporte.final()\n          if(is.null(num.fam)) return(NULL)\n          l.linea <- unique(num.fam$LINEA)%>%sort()\n          selectInput(\"dataset\", \"Filtrar por linea de produccion\", as.list(l.linea))\n     })\n     \n     #Analisis de asignacion - Grafico por puesto\n     output$grafico.final <- renderPlotly({\n          reporte <- reporte.final()\n          if(is.null(reporte)) {\n               return(NULL)\n          } else {\n\n               #crea tabla de 3 columnas ESTILO, PUESTO, TIEMPO\n               fin <- dim(reporte)[2]\n               tabla.renglon <- gather(reporte, \"PUESTO\",\"TIEMPO\",c(3:fin))\n               \n               unidades <- ifelse(input$personas, \"Personas\", \"Segundos\")\n               \n               # grafico de desviaciones por puesto\n               ggplotly(\n                    ggplot(data = tabla.renglon, aes(ESTILO, TIEMPO, colour = LINEA)) + \n                         geom_point() + \n                         facet_grid(PUESTO~., as.table = F, scales = \"free\") +\n                         xlab(\"Estilos\") +\n                         ylab(unidades)  +\n                         ggtitle(\"Dispersion de tiempo/personas para producir un par\") +\n                         theme(axis.text=element_text(size=8))\n               )\n          } \n          \n          \n     })\n     \n     #Desviaciones - escala independiente por grafico\n     free.scale.fin <- reactive({\n          b.scales = \"fixed\"\n          if (input$same.scale.fin){\n               b.scales = \"free\"\n          }\n          return(b.scales)\n          \n     })\n     \n\n     #Desviaciones - grafico por linea, dependen del combobox cual mostrar\n     obtener.criticos <- reactive({\n          reporte <- reporte.final()\n          if(is.null(reporte)) return(NULL)\n          \n          limites <- input$quant\n          \n          linea <- input$dataset\n          cols.usar <- c(3:(ncol(reporte)))\n          f.plot <- reporte%>%filter(LINEA == linea)%>%\n               gather(\"PUESTO\",\"TIEMPO\",cols.usar)\n          \n          \n          #10% inferior y superior\n          quant <- f.plot%>%\n               group_by(PUESTO)%>%\n               summarise(\"Promedio\" = mean(TIEMPO),\n                         \"Q1\" = quantile(TIEMPO, probs = limites/100), \n                         \"Q4\" = quantile(TIEMPO, probs = 1-(limites/100)))\n          \n          temp <- merge(f.plot, quant, by = \"PUESTO\")%>%\n               mutate(\"Distancia\" = sqrt((Promedio-TIEMPO)^2))\n          \n          #distancia maxima, tomando en cuanta todas las fracciones (critico)     \n          critico <- temp%>%\n               group_by(ESTILO)%>%\n               summarise(\"Distancia\" = sum(Distancia))%>%\n               mutate(\"Q1\" = quantile(Distancia, probs = limites/100), \n                      \"Q4\" = quantile(Distancia, probs = 1-(limites/100)),\n                      \"CRITICO\" = ifelse(Distancia > Q4, \"CRITICO\", \"NORMAL\"))%>%\n               select(ESTILO, CRITICO)\n          \n          for.plot <- merge(temp, critico, by = \"ESTILO\")%>%\n                      mutate(\"DESVIACION\" = ifelse(CRITICO == \"CRITICO\", \"CRITICO\",\n                                                   ifelse(TIEMPO < Q1 | TIEMPO > Q4,\"FUERA\",\"NORMAL\")))\n     })\n     \n     #Desviaciones - Imprimir los estilos criticos segun el slider de porcentaje en los limites\n     output$cancelar.criticos  <- renderTable({\n          for.plot <- obtener.criticos()\n          \n          if (is.null(for.plot)) return(NULL)\n          \n          temp <- for.plot%>%\n               filter(DESVIACION == \"CRITICO\")%>%\n               select(ESTILO, LINEA)\n          \n          criticos <- unique(temp) \n          \n          return(criticos)\n          \n     })\n     \n     #Desviaciones - Grafico por linea, dependen del combobox cual mostrar\n     output$plot.por.linea <- renderPlotly({\n          for.plot <- obtener.criticos()\n          \n          if (is.null(for.plot)) return(NULL)\n          \n          b.scales <- free.scale.fin()\n          \n          #cuando se cambian tiempos por personas\n          unidades <- ifelse(input$personas, \"Personas\", \"Segundos\")\n          \n          ggplotly(\n          ggplot(for.plot, aes(ESTILO,TIEMPO, colour = DESVIACION)) +\n               geom_point() +\n               facet_wrap(~PUESTO, ncol=2, strip.position = \"right\" ,scales = b.scales, as.table = T) +\n               theme(strip.background = element_blank(), strip.placement = \"outside\") + \n               geom_hline(data = for.plot%>%\n                               group_by(PUESTO)%>%\n                               summarise(\"Promedio\" = mean(TIEMPO)),\n                          aes(yintercept = Promedio), col = \"red\", lwd = 0.3) + \n               geom_hline(data = for.plot%>%\n                               group_by(PUESTO)%>%\n                               summarise(\"Promedio.real\" = ceiling(mean(TIEMPO))),\n                          aes(yintercept = Promedio.real), col = \"navy\", lwd = 0.5) +\n               ylab(unidades) + \n               ggtitle(\"Estilos a producir vs tiempo total de proceso por funcion\")\n          )\n     })\n     \n     #Desviaciones - Imprimir desviaciones por linea\n     output$total.fam <- renderTable({\n          reporte <- reporte.final()\n          if(is.null(reporte)) {\n               return(NULL)\n          } else {\n               totales <- reporte%>%\n                    group_by(LINEA)%>%\n                    summarise(\"Estilos por familia\"= n())\n          }\n     })\n     \n     #Desviaciones - indicador general de desviacion (imprimir)\n     output$indicador.desviacion <- renderTable({\n          tabla <- fun.indicador.desviacion()\n          if (is.null(tabla)) return(NULL)\n          temp <- tabla\n          return(temp)\n     })\n     \n     #Desviaciones - calcula tabla de desviaciones\n     fun.indicador.desviacion <- reactive({\n          reporte <- reporte.final()\n          if(is.null(reporte)) return(NULL)\n          \n               #indicador de desviacion (promedio/(max-min))\n               #crea tabla de 3 columnas ESTILO, PUESTO, TIEMPO\n               fin <- dim(reporte)[2]\n               tabla.renglon <- gather(reporte, \"PUESTO\",\"TIEMPO\",c(3:fin))\n               \n               indicador <- tabla.renglon%>%\n                    group_by(LINEA, PUESTO)%>%\n                    summarise(\"Prom\" = ceiling(mean(TIEMPO)),\n                              \"Mini\" = min(TIEMPO) ,\n                              \"Maxi\" = max(TIEMPO))%>%\n                    group_by(LINEA)%>%\n                    summarise(\"Promedio\" = sum(Prom),\n                              \"Minimo\" = sum(Mini),\n                              \"Maximo\" = sum(Maxi),\n                              \"Porcentaje de desviacion\" = round((Maximo-Minimo)/Promedio*100,2))\n               return(indicador)\n\n     })\n     \n     #Desviaciones - Imprimir valor de porcentaje de mejora\n     output$pct.mejora <- renderPrint({\n          mejora <- desviacion.mejorada()\n          if(is.null(mejora)) return(NULL)\n          \n          anterior <- fun.indicador.desviacion()\n          if(is.null(anterior)) return(NULL)\n          \n          ant <- anterior%>%\n               filter(LINEA == input$dataset)\n          \n          cat(as.numeric(100-round(mejora$NvaDesviacion/ant[5]*100,2)))\n     \n     })\n     \n     #Desviaciones - Imprimir valor de desviacion mejorada\n     output$nva.desviacion <- renderPrint({\n          mejora <- desviacion.mejorada()\n          if(is.null(mejora)) return(NULL)\n          \n          cat(as.numeric(mejora$NvaDesviacion))\n     })\n     \n     #Desviaciones - Imprimir dato de aumento de produccion\n     output$incr.produccion <- renderPrint({\n          mejora <- desviacion.mejorada()\n          if(is.null(mejora)) return(NULL)\n          \n          anterior <- fun.indicador.desviacion()\n          if(is.null(anterior)) return(NULL)\n          \n          incr <- round((1-(mejora$Maximo/anterior%>%\n                                 filter(LINEA == input$dataset)%>%\n                                 select(Maximo)))*100,2)\n          \n          cat(as.numeric(incr))\n     })\n\n     \n     #Desviaciones - indicador general de desviacion sin criticos\n     desviacion.mejorada <- reactive({\n          \n          reporte <- obtener.criticos()\n          if(is.null(reporte)) return(NULL)\n\n               mejora <- reporte%>%\n                    filter(CRITICO != \"CRITICO\")%>%\n                    select(ESTILO, LINEA, PUESTO, TIEMPO)%>%\n                    group_by(LINEA, PUESTO)%>%\n                    summarise(\"Prom\" = ceiling(mean(TIEMPO)),\n                              \"Mini\" = min(TIEMPO) ,\n                              \"Maxi\" = max(TIEMPO))%>%\n                    group_by(LINEA)%>%\n                    summarise(\"Promedio\" = sum(Prom),\n                              \"Minimo\" = sum(Mini),\n                              \"Maximo\" = sum(Maxi),\n                              \"NvaDesviacion\" = round((Maximo-Minimo)/Promedio*100,2))\n               return(mejora)\n     })\n     \n     #Desviaciones - tabla de desviaciones por linea\n     output$desviaciones <- DT::renderDataTable({\n          reporte <- reporte.final()\n          if(is.null(reporte)) return(NULL)\n          \n               #crea tabla de 3 columnas ESTILO, PUESTO, TIEMPO\n               fin <- dim(reporte)[2]\n               tabla.renglon <- gather(reporte, \"PUESTO\",\"TIEMPO\",c(3:fin))\n               \n               desviaciones <- tabla.renglon%>%\n                    group_by(LINEA, PUESTO)%>%\n                    summarise(\"Promedio\" = ceiling(mean(TIEMPO)),\n                              \"Desviacion\" = round(sd(TIEMPO),2),\n                              \"Minimo\" = min(TIEMPO) ,\n                              \"Maximo\" = max(TIEMPO))\n               DT::datatable(desviaciones, options = list(pageLength = 50))\n\n     })\n     \n     \n     #Flujo continuo -  Drop-down de departamentos, para seleccionar para flujos\n     output$flujo.deptos <- renderUI({\n          deptos <- lectura.inicial()\n          if(is.null(deptos)) return(NULL)\n          un.deptos <- unique(deptos$DEPTO)%>%sort()\n          selectInput(\"cb.deptos.flujo\", \"Selecciona departamentos para revisar\", as.list(un.deptos),\n                      multiple = T)\n     })\n     \n     #Flujo continuo -  Drop-down linea para revisar flujo\n     output$flujo.linea <- renderUI({\n          datos <- reporte.final.sin.personas()\n          if(is.null(datos)) return(NULL)\n          \n          lineas <- unique(datos$LINEA)%>%sort()\n          selectInput(\"cb.lineas.flujo\", \"Selecciona una linea\", as.list(lineas),\n                      multiple = F)\n     })\n     \n     #Flujo continuo -  Drop-down de estilos para flujo\n     output$flujo.estilo <- renderUI({\n          datos <- reporte.final.sin.personas()\n          if(is.null(datos)) return(NULL)\n          \n               datos <- datos%>%filter(LINEA == input$cb.lineas.flujo)\n               estilos <- unique(datos$ESTILO)%>%sort()\n               selectInput(\"cb.estilos.flujo\", \"Selecciona un estilo\", as.list(estilos),\n                           multiple = T)\n     })\n     \n     #Flujo continuo - calcula plantilla, completa las funciones con cero (basado en reporte final)\n     reporte.flujo <- reactive({\n          datos <- lectura.inicial()\n          if (is.null(datos)) return(NULL)\n          \n          #leer combo y definir lineas a usar, sirve para quitar estilos sin linea asignada\n          #y para quitar canteras o maquilas, dan problemas al agrupar en un solo depto pues\n          # en realidad es no se procesa junto\n          if (is.null(input$fams.selected)) return(NULL)\n          \n          #si agrupado, convertir todo a linea 1\n          #cambia los datos de la columna linea todo a 1\n          if(input$agrupado){\n               datos[,3] <- 1\n          }\n          \n          #convertir los tiempos en personas para 1000 pares al dia\n               efic <- input$eficiencia/100\n               hrs <- input$horas.trabajo\n               datos <-  datos%>%\n                    mutate(\"PERSONAS\" = ceiling(TIEMPO*1000/(efic*hrs*3600)))%>%\n                    select(DEPTO, ESTILO, LINEA, FUNCION, PERSONAS)\n          \n          #lineas seleccionadas\n          datos <- datos%>%\n               filter(LINEA %in% input$cb.lineas.flujo)\n\n          \n          #completar con cero las funciones que existen en cada depto y el estilo no las tiene\n          #primero se debe agregar todos los estilos a todas los deptos\n          estilos.fam <- unique(datos[datos$DEPTO == \"FAMILIA\",2:3])\n          #estilos.fam <<- unique(datos[datos$DEPTO == \"FAMILIA\",2:3])\n\n          #crear bd vacia\n          bd <- data.frame(\"ESTILO\" = numeric(0),\n                           \"LINEA\" = numeric(0),\n                           \"FUNCION\"= numeric(0),\n                           \"PERSONAS\" = numeric(0),\n                           \"DEPTO\" = numeric(0))\n          tiempos <- datos\n          \n          #calcula y completa con cero el personal de cada estilo que no aparece\n          for (i in input$cb.deptos.flujo){\n               #se pueden seleccionar varios deptos - es lo mas logico\n               temp <- tiempos%>%\n                    filter(DEPTO %in% i)%>%\n                    select(DEPTO, ESTILO, FUNCION, PERSONAS)%>%\n                    group_by(ESTILO, FUNCION)%>%\n                    summarise(\"PERSONAS\" = sum(PERSONAS))%>%\n                    spread(FUNCION,PERSONAS, drop = FALSE, fill = 0)\n               datos <- merge(estilos.fam, temp, by = \"ESTILO\")\n               \n               \n               #agrupar en una sola linea\n               #cambia los datos de la columna linea todo a 1\n               if(input$agrupado){\n                    datos[,2] <- 1\n               }\n               \n               #convertir NAS en cero\n               datos[is.na(datos)]<-0\n               \n               #estilo y linea como factor\n               datos[,1] <- as.factor(datos[,1])\n               datos[,2] <- as.factor(datos[,2])\n               #nas a cero\n               datos[is.na(datos)] <- 0\n               \n               #hacer formato trabajable\n               datos <- gather(datos, FUNCION, PERSONAS, 3:ncol(datos))\n               \n               #agregar el departamento\n               datos$DEPTO <- i\n               \n               #bd completa, todos los deptos, y funciones completas para cada depto\n               bd <- rbind(bd, datos)\n               \n          }\n          \n          #plantilla basica por promedio\n          plantilla <- bd%>%\n               group_by(LINEA, DEPTO, FUNCION)%>%\n               summarise(\"PLANTILLA\" = ceiling(mean(PERSONAS)))\n          \n          #diferencias por estilo vs plantilla\n          completa <- merge(bd, plantilla , by = c(\"LINEA\",\"DEPTO\",\"FUNCION\"))\n          \n          return(completa)\n          \n          \n     })  \n     \n     \n     #Flujo continuo - calcula plantilla basica, metas y cumplimiento por depto, linea\n     full.flujo <- reactive({\n          \n               datos <- reporte.flujo()\n               if(is.null(datos)) return(NULL)\n               \n               estilos = input$cb.estilos.flujo\n               #cuantos estilos seleccionados\n               cuantos <- length(input$cb.estilos.flujo)               \n               if (cuantos == 0) return(NULL)\n               if (length(input$cb.lineas.flujo) == 0) return(NULL)\n               \n               #solo los estilos seleccionados\n               datos <- datos%>%\n                    filter(ESTILO %in% estilos)\n               \n               #si no hay pares por producir por linea utilizar 100 pares por hora\n               #if(nrow(tb.porproduc)==0) return(NULL)\n               \n               #acumular meta de los estilos seleccionados si es mas de uno\n               if (cuantos > 1){\n                    tabla.plot <- datos%>%\n                         group_by(DEPTO, FUNCION)%>%\n                         summarise(\"PERSONAS\" = ceiling(sum(PERSONAS)/cuantos),\n                                   \"PLANTILLA\" = min(sum(PLANTILLA)/cuantos),\n                                   \"Pct.meta\" = ifelse(PERSONAS == 0, \n                                                       ceiling(300), \n                                                       ceiling((PLANTILLA/(PERSONAS))*100)))%>%\n                         mutate(\"ESTILO\" = \"AGRUPADO\")\n               } else {\n                    \n                    tabla.plot <- datos%>%\n                         mutate(\"Pct.meta\" = ifelse(PERSONAS == 0, \n                                                    300, \n                                                    ceiling((PLANTILLA/PERSONAS)*100)))\n               }\n               \n               plot.final <- tabla.plot%>%\n                    arrange(DEPTO, FUNCION, Pct.meta)%>%\n                    mutate(\"DEPTOFUNC\" = paste(DEPTO,\"/\",FUNCION),\n                           \"EFIC\" = round(min(Pct.meta)/Pct.meta,2),\n                           \"DIF\" = PERSONAS - PLANTILLA)\n               \n               return(plot.final)\n               \n     })\n\n     #Flujo continuo - tabla del grafico (pendiente si presentar o no)\n     output$tabla.plot <- DT::renderDataTable({\n          plot.final <- full.flujo()\n\n          if (is.null(plot.final))  return(NULL)\n          \n          plot.final <- plot.final%>%\n               select(ESTILO, DEPTO, FUNCION, PERSONAS, PLANTILLA, \"PCT.META\" = Pct.meta, EFIC)\n          \n          DT::datatable(plot.final, options = list(pageLength = 25))\n     })\n     \n     #Flujo continuo - tabla completa de flujo (pendiente si presentar o no)\n     output$tabla.full <- DT::renderDataTable({\n          plot.final <- reporte.flujo()\n          \n          if (is.null(plot.final))  return(NULL)\n          DT::datatable(plot.final, options = list(pageLength = 25))\n     })\n     \n     #Flujo continuo - tabla completa de flujo balanceado (pendiente si presentar o no)\n     output$balanceo <- DT::renderDataTable({\n          balanceado <- balanceo()\n          if (is.null(balanceado)) return(NULL)\n          \n          balanceado <- balanceado%>%\n               select(ESTILO, DEPTO, FUNCION, PERSONAS, PLANTILLA, \"PCT.META\" = Pct.meta, EFIC)\n          \n          DT::datatable(balanceado, options = list(pageLength = 25))\n     })\n     \n     #Flujo continuo - realiza el balanceo para mejorar metas y eficiencia\n     balanceo <- reactive({\n          \n          plot.final <- full.flujo()\n          if (is.null(plot.final))  return(NULL)\n          #cuantos estilos seleccionados\n          if (length(input$cb.estilos.flujo) == 0) return(NULL)\n          if (length(input$cb.lineas.flujo) == 0) return(NULL)\n          \n          \n          cumplimiento = min(plot.final$Pct.meta)\n          eficiencia = mean(plot.final$EFIC)\n          if (is.infinite(cumplimiento)) return(NULL)\n          \n          #buscar cumplimineto y eficiencia mayor al 90 o 10 iteraciones\n          iter = 0\n          \n          movimientos <- data.frame(\"Origen\" = numeric(0),\"Destino\" = numeric(0))\n\n          while((cumplimiento < 90 | eficiencia < .9) & iter < 5){\n               dona <- min(plot.final$DIF)\n               recibe <- min(plot.final$Pct.meta)\n               \n               movimientos <- c(movimientos, data.frame(\"Origen\" = dona, \"Destino\" = recibe))\n               #movimientos <<- c(movimientos, data.frame(\"Origen\" = dona, \"Destino\" = recibe))\n               \n               #pueden haber 2 que donan y 2 que reciben, se elige el primero\n               funcionrecibe <- head(plot.final[plot.final$Pct.meta == recibe,]$FUNCION,1)\n               funciondona <- head(plot.final[plot.final$DIF == dona,]$FUNCION,1)\n               \n               if (dona >= 0) break\n     \n               #en el minimo, quien recibe +1, quien dona -1\n               nva.plantilla.mas <- plot.final[plot.final$FUNCION == funcionrecibe,]$PLANTILLA + 1\n               nva.plantilla.menos <- plot.final[plot.final$FUNCION == funciondona,]$PLANTILLA - 1\n               \n               #cuantas personas quiere el estilo en esos dos, donador y receptor\n               personas.mas <- plot.final[plot.final$FUNCION == funcionrecibe,]$PERSONAS\n               personas.menos <- plot.final[plot.final$FUNCION == funciondona,]$PERSONAS\n               \n               #nuevas metas\n               nva.meta.mas <- round((nva.plantilla.mas /personas.mas)*100,2)\n               nva.meta.menos <- ifelse(personas.menos ==0,300, round((nva.plantilla.menos /personas.menos)*100,2))\n               \n               #si ahora min meta es mayor (aun cuando le quitamos a una persona, actualiza)\n               if(recibe < nva.meta.menos | nva.meta.menos %in% Inf){\n                    nva.plantilla.mas -> plot.final[plot.final$FUNCION == funcionrecibe,]$PLANTILLA\n                    nva.plantilla.menos -> plot.final[plot.final$FUNCION == funciondona,]$PLANTILLA\n                    \n                    plot.final <- plot.final%>%\n                         mutate(\"Pct.meta\" = ifelse(PERSONAS == 0, \n                                                    300, \n                                                    ceiling((PLANTILLA/PERSONAS)*100)))%>%\n                         arrange(DEPTO, FUNCION, Pct.meta)%>%\n                         mutate(\"DEPTOFUNC\" = paste(DEPTO,\"/\",FUNCION),\n                                \"EFIC\" = round(min(Pct.meta)/Pct.meta,2),\n                                \"DIF\" = PERSONAS - PLANTILLA)\n                    \n               } else { break }\n               \n               #actualiza para el ciclo\n               cumplimiento = min(plot.final$Pct.meta)\n               eficiencia = mean(plot.final$EFIC)\n               \n               dona <- min(plot.final$DIF)\n               recibe <- min(plot.final$Pct.meta)\n               \n               iter=iter+1\n          }\n          \n          return(plot.final)\n     })\n     \n     \n     #Flujo continuo - Imprime cumplimiento de meta inicial\n     output$cumpl.meta <- renderPrint({\n          plot.final <- full.flujo()\n          \n          if (is.null(plot.final))  return(NULL)\n          \n          cat(paste(ceiling(min(plot.final$Pct.meta))),\"%\")\n     })\n     \n     #Flujo continuo - Imprime aumento en pares producidos al balancear\n     output$aumento.pares <- renderPrint({\n          inicial <- full.flujo()\n          balanceado <- balanceo()\n          \n          if (is.null(inicial))  return(NULL)\n          if (is.null(balanceado))  return(NULL)\n          \n          mas.pares <- (((min(balanceado$Pct.meta))/ceiling(min(inicial$Pct.meta)))-1)*100*input$horas.trabajo*5\n          \n          cat(format(ceiling(mas.pares), decimal.mark=\".\",big.mark=\",\", small.mark=\",\", small.interval=3))\n     })\n     \n     #Flujo continuo - Imprime aumento en facturacion al balancear\n     output$aumento.facturacion <- renderPrint({\n          inicial <- full.flujo()\n          balanceado <- balanceo()\n          \n          if (is.null(inicial))  return(NULL)\n          if (is.null(balanceado))  return(NULL)\n          \n          mas.pares <- (((min(balanceado$Pct.meta))/ceiling(min(inicial$Pct.meta)))-1)*100*input$horas.trabajo*5\n          \n          cat(format(ceiling(mas.pares)*input$precio.prom, decimal.mark=\".\",big.mark=\",\", small.mark=\",\", small.interval=3))\n     })\n     \n     #Flujo continuo - Imprime cumplimiento mejorado al balancear\n     output$cumpl.mejorado <- renderPrint({\n          plot.final <- balanceo()\n          \n          if (is.null(plot.final))  return(NULL)\n          \n          cat(paste(ceiling(min(plot.final$Pct.meta))),\"%\")\n     })\n     \n     #Flujo continuo - Imprime eficiencia esperada inicial\n     output$ef.esperada <- renderPrint({\n          plot.final <- full.flujo()\n          \n          if (is.null(plot.final))  return(NULL)\n          \n          cat(paste(ceiling(mean(plot.final$EFIC)*100),\"%\"))\n     })\n     \n     #Flujo continuo - Imprime eficiencia mejorada con balanceo\n     output$ef.mejorada <- renderPrint({\n          plot.final <- balanceo()\n          \n          if (is.null(plot.final))  return(NULL)\n          \n          cat(paste(ceiling(mean(plot.final$EFIC)*100),\"%\"))\n     })\n     \n     #Flujo continuo - tabla de movimientos requeridos con balanceo\n     output$tabla.movimientos <- renderTable({\n          datos.normal <- full.flujo()\n          if (is.null(datos.normal))  return(NULL)\n          datos.normal <- datos.normal%>%mutate(\"Datos\" = \"Base\")\n          datos.normal$PLANTILLA <- datos.normal$PLANTILLA * -1\n          \n          balanceado <- balanceo()\n          balanceado <- balanceado%>%mutate(\"Datos\" = \"Balanceado\")\n          \n          \n          #junta las tablas\n          result <- rbind(datos.normal, balanceado)%>%\n               group_by(FUNCION)%>%\n               summarise(\"CANTIDAD\" = sum(PLANTILLA))%>%\n               filter(CANTIDAD != 0)\n          \n          return(result)\n          \n     })\n     \n     #Flujo continuo - Observa cuando se seleccionan estilos\n     observeEvent(input$cb.estilos.flujo, {\n          \n          #Flujo continuo - Imprime grafico de flujo continuo\n          output$plot.flujo <- renderPlotly({\n               \n               datos.normal <- full.flujo()\n               if (is.null(datos.normal))  return(NULL)\n               datos.normal <- datos.normal%>%mutate(\"Datos\" = \"Base\")\n               \n               balanceado <- balanceo()\n               balanceado <- balanceado%>%mutate(\"Datos\" = \"Balanceado\")\n               \n               #META BASE\n               intercepts <- datos.normal%>%\n                    group_by(ESTILO, DEPTO)%>%\n                    filter(Pct.meta > 0)%>%\n                    summarise(\"Meta.real\" = min(Pct.meta))\n               \n               #META BALANCEO\n               intercepts.b <- balanceado%>%\n                    group_by(ESTILO, DEPTO)%>%\n                    filter(Pct.meta > 0)%>%\n                    summarise(\"Meta.real\" = min(Pct.meta))\n               \n               para.plot <- rbind(datos.normal, balanceado)\n               \n               ggplot(para.plot, aes(DEPTOFUNC, Pct.meta, colour = Datos, group = Datos)) + \n                    geom_point(size = 2) + geom_line() + \n                    scale_x_discrete(labels = substr(para.plot$FUNCION,1,3)) +\n                    geom_hline(data = intercepts, aes(yintercept =  Meta.real, colour = DEPTO))+\n                    geom_hline(data = intercepts.b, aes(yintercept =  Meta.real, colour = DEPTO))+\n                    expand_limits(y = c(0,100)) + \n                    ggtitle(\"Porcentaje de cumplimiento de meta por funcion\")\n               \n          })\n          \n     })\n     \n     \n     #General - Oberva boton agregar y actualiza todo lo referente a analisis de personal\n     #cuando se carga un meta de pares por linea\n     observeEvent(input$agregar, {\n          \n          #Analisis de desviaciones - incremento en facturacion quitando criticos\n          output$inc.facturacion <- renderPrint({\n               mejora <- desviacion.mejorada()\n               if(is.null(mejora)) return(NULL)\n               \n               #si no hay pares por producir por linea no hace el calculo de personas\n               if(nrow(tb.porproduc)==0) return(NULL)               \n               \n               anterior <- fun.indicador.desviacion()\n               if(is.null(anterior)) return(NULL)\n               \n               incr <- round((1-(mejora$Maximo/anterior%>%\n                                      filter(LINEA == input$dataset)%>%\n                                      select(Maximo)))*100,2)\n\n               l.actual <- input$dataset\n               par.fam <- tb.porproduc%>%\n                    filter(LINEA == l.actual)%>%\n                    select(PARES)\n               \n               if (nrow(par.fam)==0) return(cat(\"Sin pares por producir\"))\n               \n               mas.fact <- as.numeric(ceiling((par.fam * (incr/100) * as.numeric(input$precio.prom))*5))\n\n               cat(format(mas.fact, decimal.mark=\".\",big.mark=\",\", small.mark=\",\", small.interval=3))\n          })\n          \n          #Analisis de personal - genera plantilla basica por linea, puesto, base de las demas\n          calcular.plantilla <- reactive({\n               temp <- reporte.final.sin.personas()\n               if(is.null(temp)) return(NULL)\n               #si no hay pares por producir por linea no hace el calculo\n               if(nrow(tb.porproduc)==0) return(NULL)\n               \n               fin <- dim(temp)[2]\n               efic <- input$eficiencia/100\n               hrs <- input$horas.trabajo\n               sds <- input$sds\n               \n\n               tabla.renglon <- gather(temp, \"PUESTO\",\"TIEMPO\",c(3:fin))%>%\n                    merge(tb.porproduc, by = \"LINEA\")%>%\n                    mutate(\"PERSONAS\" = ceiling(TIEMPO*PARES/(efic*hrs*3600)))%>%\n                    group_by(LINEA, PUESTO)%>%\n                    summarise(\"TIEMPO\" = ceiling(mean(TIEMPO)),\n                              \"PARES\" = min(PARES),\n                              \"PERSONAS\" = ceiling(mean(PERSONAS+(sds*sd(PERSONAS)))))\n\n               \n               return(tabla.renglon)\n               \n          })\n          \n          #Analisis de personal - Tabla por linea-puesto\n          output$PersonalPorlinea <- DT::renderDataTable({\n               tabla.renglon <- calcular.plantilla()\n               if (is.null(tabla.renglon)) return(NULL)\n          \n               DT::datatable(tabla.renglon, options = list(pageLength = 50))\n               \n          })\n          \n\n          #Analisis de personal - plantilla basica, Calcula restriccion y eficiencia por funcion\n          eficiencia.funcion <- reactive({\n               temp <- reporte.final.sin.personas()\n               if(is.null(temp)) return(NULL)\n               #si no hay pares por producir por linea no hace el calculo\n               if(nrow(tb.porproduc)==0) return(NULL)\n               \n               fin <- dim(temp)[2]\n               efic <- input$eficiencia/100\n               hrs <- input$horas.trabajo\n               sds <- input$sds\n          \n          #primero convierte a personas y luego redondea\n          plantilla <- gather(temp, \"PUESTO\",\"TIEMPO\",c(3:fin))%>%\n               merge(tb.porproduc, by = \"LINEA\")%>%\n               mutate(\"PERSONAS\" = ceiling(TIEMPO*PARES/(efic*hrs*3600)))%>%\n               group_by(LINEA, PUESTO)%>%\n               summarise(\"TIEMPO\" = ceiling(mean(TIEMPO)),\n                         \"PARES\" = min(PARES),\n                         \"PLANTILLA\" = ceiling(mean(PERSONAS+(sds*sd(PERSONAS)))))%>%\n               select(LINEA, PUESTO, PARES, PLANTILLA)\n\n  \n               \n               tabla.renglon <- gather(temp, \"PUESTO\",\"TIEMPO\",c(3:fin))%>%\n                    merge(plantilla, by = c(\"LINEA\",\"PUESTO\"))%>%\n                    mutate(\"PERSONAS\" = ceiling(TIEMPO*PARES/(efic*hrs*3600)),\n                           \"META\" = ceiling(PLANTILLA/PERSONAS*100),\n                           \"PARES.PRODUCCION\" = ceiling(PARES*META/100),\n                           \"CAPACIDAD.FUNCION\" = ifelse(PARES<PARES.PRODUCCION, PARES, PARES.PRODUCCION))\n               \n               meta.estilo <- tabla.renglon%>%\n                    group_by(ESTILO)%>%\n                    summarise(\"PROD.RESTRICCION\" = min(CAPACIDAD.FUNCION))\n                    \n               result <- merge(tabla.renglon, meta.estilo, by = \"ESTILO\")%>%\n                    mutate(\"EFICIENCIA\" =ceiling(PROD.RESTRICCION/PARES.PRODUCCION*100),\n                           \"APROVECHAMIENTO\" = round(EFICIENCIA/100*PLANTILLA,2)) \n               \n\n               return(result)\n          })\n          \n          \n          #Analisis de personal - Personal por linea con eficiencias\n          output$PersonalPorEstilo <- DT::renderDataTable({\n               result <- eficiencia.funcion()\n               if (is.null(result)) return(NULL)\n               \n               DT::datatable(result, options = list(pageLength = 50))\n               \n          })\n          \n          #Analisis de personal - eficiencia por estilo (para graficar)\n          output$eficiencia.estilo <- renderPlotly({\n               temp <- eficiencia.funcion()\n               if(is.null(temp)) return(NULL)\n               \n               eficiencia.por.estilo <- temp%>%\n                    group_by(ESTILO)%>%\n                    summarise(\"DISPONIBLE\" = sum(PLANTILLA),\n                              \"UTILIZADO\" = sum(APROVECHAMIENTO))%>%\n                    mutate(\"EFICIENCIA\" = ceiling(UTILIZADO/DISPONIBLE*100),\n                           \"NIVEL\" = ifelse(EFICIENCIA > 85, \"A-BUENO\", ifelse(EFICIENCIA > 50, \"B-REGULAR\",\"C-CRITICO\")))\n               \n               paleta <- c(\"darkgreen\",\"gold2\",\"red\")\n               \n               ggplotly(\n                    ggplot(data = eficiencia.por.estilo, aes(ESTILO, EFICIENCIA, colour = NIVEL)) +\n                         geom_point() + \n                         scale_color_manual(values = paleta)+ \n                         expand_limits(y=c(0,100))\n                    \n               )\n          })\n          \n          \n          #Analisis de personal - eficiencia por estilo (para graficar)\n          output$eficiencia.linea <- DT::renderDataTable({\n               temp <- eficiencia.funcion()\n               if(is.null(temp)) return(NULL)\n               \n               eficiencia.por.linea <- temp%>%\n                    group_by(LINEA, ESTILO)%>%\n                    summarise(\"DISPONIBLE\" = sum(PLANTILLA),\n                              \"UTILIZADO\" = sum(APROVECHAMIENTO))%>%\n                    mutate(\"TEMP\" = ceiling(UTILIZADO/DISPONIBLE*100))%>%\n                    group_by(LINEA)%>%\n                    summarise(\"PROMEDIO\" = ceiling(mean(TEMP)),\n                              \"MEDIANA\" = ceiling(quantile(TEMP, probs = 0.5)),\n                              \"DESVIACION\" = round(sd(TEMP),2))\n               \n               DT::datatable(eficiencia.por.linea, options = list(pageLength = 10))\n          })\n          \n          #Analisis de personal - eficiencia por estilo (para graficar)\n          output$meta.linea <- DT::renderDataTable({\n               temp <- eficiencia.funcion()\n               if(is.null(temp)) return(NULL)\n               \n               meta.por.linea <- temp%>%\n                    group_by(LINEA)%>%\n                    summarise(\"PROMEDIO\" = ceiling(mean(PROD.RESTRICCION)),\n                              \"MEDIANA\" = ceiling(quantile(PROD.RESTRICCION, probs = 0.5)),\n                              \"DESVIACION\" = round(sd(PROD.RESTRICCION),2),\n                              \"PAR.PRESUP\" = min(PARES))%>%\n                    mutate(\"CUMPLIMIENTO\" = ceiling(PROMEDIO/PAR.PRESUP*100))%>%\n                    select(PROMEDIO, CUMPLIMIENTO, MEDIANA, DESVIACION)\n               \n               DT::datatable(meta.por.linea, options = list(pageLength = 10))\n          })\n\n          \n          #Analisis de personal - Imprime personas por funcion\n          output$total_puesto <- renderTable({\n               tabla.totales <- calcular.plantilla()\n               if (is.null(tabla.totales)) return(NULL)\n               \n               result <- tabla.totales%>%\n                    group_by(PUESTO)%>%\n                    summarise(\"PERSONAS\" = sum(PERSONAS))\n               \n          })\n          \n          #Analisis de personal - Imprime Total por linea de produccion\n          output$Totales.por.linea <- renderTable({\n               tabla.totales <- calcular.plantilla()\n               if (is.null(tabla.totales)) return(NULL)\n               \n               tabla.renglon <- tabla.totales%>%\n                    group_by(LINEA)%>%\n                    summarise(\"PERSONAS\" = sum(PERSONAS))\n               \n               sueldo <- input$sueldo.prom\n               \n               #calcula produccion promedio real por la eficiencia de balanceo\n               efic <- eficiencia.funcion()\n               if(is.null(efic)) return(NULL)\n\n               prod.prom <- efic%>%\n                    group_by(LINEA)%>%\n                    summarise(\"PROD.REAL\" = ceiling(mean(PROD.RESTRICCION)))\n               \n               \n               result <- merge(tabla.renglon, prod.prom, by = \"LINEA\")%>%\n                    mutate(\"COSTO.PAR\" = round((sueldo*PERSONAS)/(PROD.REAL*5),2))%>%\n                    select(LINEA, PERSONAS, COSTO.PAR)\n               \n               return(result)\n               \n          })\n          \n          #Analisis de personal - costo promedio de mano de obra\n          output$mo.promedio <- renderPrint({\n               tabla.totales <- calcular.plantilla()\n               if (is.null(tabla.totales)) return(NULL)\n               \n               tabla.renglon <- tabla.totales%>%\n                    group_by(LINEA)%>%\n                    summarise(\"PERSONAS\" = sum(PERSONAS))\n               \n               sueldo <- input$sueldo.prom\n               \n               #calcula produccion promedio real por la eficiencia de balanceo\n               efic <- eficiencia.funcion()\n               if(is.null(efic)) return(NULL)\n               \n               prod.prom <- efic%>%\n                    group_by(LINEA)%>%\n                    summarise(\"PROD.REAL\" = ceiling(mean(PROD.RESTRICCION)))\n               \n               total.pares <- sum(prod.prom$PROD.REAL)\n\n               result <- merge(tabla.renglon, prod.prom, by = \"LINEA\")%>%\n                    mutate(\"COSTO.PAR\" = round((sueldo*PERSONAS)/(PROD.REAL*5),2),\n                           \"PRECIO.POND\" = COSTO.PAR*PROD.REAL)\n               \n               \n               cat(round(sum(result$PRECIO.POND)/total.pares,2))\n               \n          })\n          #Analisis de personal - incremento en la facturacion por plantilla basica correcta\n          output$incr.fact.plantilla <- renderPrint({\n               tabla.totales <- calcular.plantilla()\n               if (is.null(tabla.totales)) return(NULL)\n               \n               tabla.renglon <- tabla.totales%>%\n                    group_by(LINEA)%>%\n                    summarise(\"PERSONAS\" = sum(PERSONAS))\n               \n               \n               #calcula produccion promedio real por la eficiencia de balanceo\n               efic <- eficiencia.funcion()\n               if(is.null(efic)) return(NULL)\n               \n               prod.prom <- efic%>%\n                    group_by(LINEA)%>%\n                    summarise(\"PROD.REAL\" = ceiling(mean(PROD.RESTRICCION)))\n               \n               total.pares <- sum(prod.prom$PROD.REAL)\n               \n               cat(format(total.pares*5*input$precio.prom, decimal.mark=\".\",big.mark=\",\", small.mark=\",\", small.interval=3))\n               \n          })\n          #Analisis de personal - facturacion menos costo de mo\n          output$fact.mo <- renderPrint({\n               tabla.totales <- calcular.plantilla()\n               if (is.null(tabla.totales)) return(NULL)\n               \n               tabla.renglon <- tabla.totales%>%\n                    group_by(LINEA)%>%\n                    summarise(\"PERSONAS\" = sum(PERSONAS))\n               \n               costo.mo <- sum(tabla.renglon$PERSONAS)*input$sueldo.prom\n               \n               #calcula produccion promedio real por la eficiencia de balanceo\n               efic <- eficiencia.funcion()\n               if(is.null(efic)) return(NULL)\n               \n               prod.prom <- efic%>%\n                    group_by(LINEA)%>%\n                    summarise(\"PROD.REAL\" = ceiling(mean(PROD.RESTRICCION)))\n               \n               total.pares <- sum(prod.prom$PROD.REAL)\n\n               cat(format(total.pares*5*input$precio.prom - costo.mo, decimal.mark=\".\",big.mark=\",\", small.mark=\",\", small.interval=3))\n               \n          })\n          \n          #Analisis de personal - facturacion menos costo de mo\n          output$total.mo <- renderPrint({\n               tabla.totales <- calcular.plantilla()\n               if (is.null(tabla.totales)) return(NULL)\n               \n               tabla.renglon <- tabla.totales%>%\n                    group_by(LINEA)%>%\n                    summarise(\"PERSONAS\" = sum(PERSONAS))\n               \n               costo.mo <- sum(tabla.renglon$PERSONAS)*input$sueldo.prom\n               \n               cat(format(costo.mo, decimal.mark=\".\",big.mark=\",\", small.mark=\",\", small.interval=3))\n               \n          })\n          \n          \n          #analisiS de personal - Gran total de personas en la plantilla\n          output$grantotal <- renderPrint({\n               tabla.totales <- calcular.plantilla()\n               if (is.null(tabla.totales)) return(NULL)\n               \n               cat(round(sum(tabla.totales$PERSONAS)))\n          })\n     })\n     \n     \n})\n",
    "created" : 1493157920485.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1138816002",
    "id" : "3398F1EA",
    "lastKnownWriteTime" : 1493649010,
    "last_content_update" : 1493649010,
    "path" : "~/Perugia/modelos-criticos/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}